// Generated by vscode-ojs: Observable Notebook Kit compiled definitions

function cell_1(md, filteredCalls) {

return (
md`## Phone Call Dashbord

_Current selection count:  ${filteredCalls.length}_
`
)

}
function cell_2(display, timeline) {

display(timeline.element);

}
async function cell_3(html, width, display) {

const { GraphHtml } = await import("https://cdn.jsdelivr.net/npm/@hpcc-js/graph/+esm").then((module) => {
  if (!("GraphHtml" in module)) throw new SyntaxError(`export 'GraphHtml' not found`);
  return module;
});


const placeholder = html`<div style="height:400px;width:${width};padding-bottom:10px"></div>`;
display(placeholder);
const graph = new GraphHtml()
  .target(placeholder)
  .dragSingleNeighbors(true)
  .edgeColor("#287EC4")
  .edgeStrokeWidth(1.66)
  .edgeArcDepth(2.5)
  .forceDirectedAlphaDecay(0.01)
  .layout("Circle")
  .applyScaleOnLayout(false)
  .on("vertex_click", (row, col, sel) => console.log("click", row, col, sel))
  .on("vertex_dblclick", (row, col, sel) => console.log("dblclick", row, col, sel))
  .on("vertex_mousein", (row, col, sel) => console.log("mousein", row, col, sel))
  .on("vertex_mouseover", (row, col, sel) => console.log("mouseover", row, col, sel))
  .on("vertex_mouseout", (row, col, sel) => console.log("mouseout", row, col, sel))
  .render()
  ;
return {GraphHtml,placeholder,graph};

}
function cell_4(d3) {

function binCalls(calls) {
  const [minDate, maxDate] = d3.extent(calls, d => d.start);
  const dayThresholds = d3.timeDay.range(
    d3.timeDay.floor(minDate),
    d3.timeDay.offset(d3.timeDay.floor(maxDate), 1)
  );
  const dayBins = d3.bin()
    .value(d => +d.start)
    .thresholds(dayThresholds)(calls);
  return dayBins.map(b => ({ day: new Date(b.x0), count: b.length }));
}
return {binCalls};

}
function cell_5(d3) {

function binCallsByCluster(calls) {
  if (!calls || !calls.length) return [];
  const [minDate, maxDate] = d3.extent(calls, d => d.start);
  const dayThresholds = d3.timeDay.range(
    d3.timeDay.floor(minDate),
    d3.timeDay.offset(d3.timeDay.floor(maxDate), 1)
  );
  const dayBins = d3.bin()
    .value(d => +d.start)
    .thresholds(dayThresholds)(calls);

  // For each day bin, count by cluster type
  const out = [];
  for (const b of dayBins) {
    const counts = d3.rollups(
      b,
      v => v.length,
      d => d.cluster_type ?? d.caller_type
    );
    for (const [cluster_type, count] of counts) {
      out.push({ day: new Date(b.x0), cluster_type, count });
    }
  }
  return out;
}
return {binCallsByCluster};

}
function cell_6(binCalls, calls) {

const binnedCalls = binCalls(calls);
  
return {binnedCalls};

}
function cell_7(binCalls, filteredCalls) {

const filteredBinnedCalls = binCalls(filteredCalls);
  
return {filteredBinnedCalls};

}
function cell_8(binCallsByCluster, calls, filteredCalls) {

const binnedCallsByCluster = binCallsByCluster(calls);
const filteredBinnedCallsByCluster = binCallsByCluster(filteredCalls);
return {binnedCallsByCluster,filteredBinnedCallsByCluster};

}
function cell_9(Plot, binnedCalls, setStartEnd, d3) {

return (
Plot.plot({
  width: 960,
  height: 200,
  x: { type: "utc", label: "Day", labelAnchor: "right" },
  y: { grid: true, label: "# Calls" },

  marks: [
    Plot.areaY(binnedCalls, { x: "day", y: "count", curve: "catmull-rom", fillOpacity: 0.2 }),
    Plot.lineY(binnedCalls, { x: "day", y: "count", curve: "catmull-rom" }),
    Plot.ruleY([0]),
    (index, scales, channels, dimensions, context) => {
      const x1 = dimensions.marginLeft;
      const x2 = dimensions.width - dimensions.marginRight;
      const y1 = dimensions.marginTop;
      const y2 = dimensions.height - dimensions.marginBottom;
      const brushed = (event) => setStartEnd(event.selection?.map(scales.x.invert));
      const brush = d3.brushX().extent([[x1, y1], [x2, y2]]).on("brush end", brushed);
      return d3.create("svg:g").call(brush).node();
    }
  ]
})
)

}
function cell_10(Plot, width, filteredBinnedCallsByCluster, phoneEntityTypeToTypeDict) {

return (
Plot.plot({
  width,
  height: 200, // per-facet height; total scales with number of cluster_type facets
  // marginLeft: 60,
  marginRight: 80,
  x: { type: "utc", label: "Day", labelAnchor: "right" },
  y: { grid: true, label: "# Calls" },
  marks: [
    Plot.areaY(
      filteredBinnedCallsByCluster,
      { x: "day", y: "count", fy: "cluster_type", curve: "step", fillOpacity: 0.2, fill: d => phoneEntityTypeToTypeDict[d.cluster_type].color }
    ),
    Plot.lineY(
      filteredBinnedCallsByCluster,
      { x: "day", y: "count", fy: "cluster_type", curve: "step", stroke: d => phoneEntityTypeToTypeDict[d.cluster_type].color }
    ),
    Plot.ruleY([0])
  ]
})
)

}
function cell_11(Inputs, filteredCalls, backColor, phoneIdToEntityDict, formatDuration) {

return (
Inputs.table(filteredCalls, {
  columns: ["start", "caller_id", "callee_id", "duration"],
  header: {
    start: "When",
    caller_id: "By",
    callee_id: "To",
    duration: "Duration",
  },
  format: {
    start: (d) => d.toLocaleDateString() + " " + d.toLocaleTimeString(),
    caller_id: (d) => backColor(phoneIdToEntityDict[d]) ?? d,
    callee_id: (d) => backColor(phoneIdToEntityDict[d]) ?? d,
    duration: (d) => formatDuration(d),
  }
})
)

}
function cell_12(md) {

return (
md`---

## Rough Work

_GJS rough work_
`
)

}
function cell_13(md) {

return (
md`
### Table Helpers`
)

}
function cell_14(Mutable, calls, start, end) {

const filteredCallsMap = Mutable({});
const filteredCalls = calls.filter((d, idx) => {
  if (idx === 0) {
    filteredCallsMap.value = {};
  }
  const retVal = (!start || d.start >= start) && (!end || d.start < end);
  if (retVal) {
    filteredCallsMap.value[d.caller_id] = true;
    filteredCallsMap.value[d.callee_id] = true;
  }
  return retVal;
});
return {filteredCallsMap,filteredCalls};

}
function cell_15(md) {

return (
md`filteredCallsMap`
)

}
function cell_16(display, filteredCallsMap) {

display(filteredCallsMap);

}
function cell_17(md) {

return (
md`filteredCalls`
)

}
function cell_18(display, filteredCalls) {

display(filteredCalls);

}
function cell_19() {

function formatDuration(ms) {
  if (ms == null || isNaN(ms)) return "";
  const totalSeconds = Math.max(0, Math.round(ms / 1000));
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  if (minutes === 0) return seconds + "s";
  return minutes + "m " + seconds + "s";
}
return {formatDuration};

}
function cell_20(d3, htl, phoneEntityTypeToTypeDict) {

function readableColor(backgroundColor) {
  const rgb = d3.rgb(backgroundColor);
  const brightness = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
  return brightness > 128 ? "black" : "white";
}

function backColor(entity) {
  return htl.html`<div style="background: ${phoneEntityTypeToTypeDict[entity.type].color};color: ${readableColor(phoneEntityTypeToTypeDict[entity.type].color)};padding: 0 0.5rem;justify-content: end;">${entity.label}</div>`
}
return {readableColor,backColor};

}
function cell_21(Mutable) {

const start = Mutable(null);
const end = Mutable(null);
const setStartEnd = (se) => {
  start.value = se?.[0] ?? 0;
  end.value = se?.[1] ?? Math.Infinity;
}
return {start,end,setStartEnd};

}
function cell_22(md) {

return (
md`---

### Graph Helpers`
)

}
function cell_23(Mutable, adjacencyList, phoneIdToEntityDict, phoneEntityTypeToTypeDict) {

const idxMap = {};
const edgeIdxMap = {};
const vertices = Mutable([]);
const edges = Mutable([]);

vertices.value = Object.keys(adjacencyList).map((key, idx) => {
  const entity = phoneIdToEntityDict[+key];
  const categoryColor = phoneEntityTypeToTypeDict[entity.type].color;
  const vertex = {
    categoryID: entity.type,
    id: +key,
    text: entity.label,
    icon: {
      imageChar: "fa-user",
      height: 32,
      fill: categoryColor,
    }
  }
  vertex.textBoxAnnotationsS = [
    // {
    //   text: "fa-star",
    //   fill: "red",
    //   stroke: "darkred"
    // }
  ];
  idxMap[+key] = vertex;

  const links = adjacencyList[key];
  Object.keys(links).forEach((link, idx) => {
    const id = +key < +link ? `${key}-${link}` : `${link}-${key}`;
    const edge = {
      id,
      source: +key,
      target: +link,
      __calls: links[link],
    };
    if (edgeIdxMap[edge.id]) {
      edgeIdxMap[edge.id].__calls.push(...edge.__calls);
    } else {
      edgeIdxMap[edge.id] = edge;
    }
  });

  return vertex;
});

edges.value = Object.values(edgeIdxMap).map((edge) => {
  edge.source = idxMap[edge.source];
  edge.target = idxMap[edge.target];
  return edge;
}).filter((edge) => edge.source && edge.target);
return {idxMap,edgeIdxMap,vertices,edges};

}
function cell_24(graph, vertices, edges) {

graph
    .data({ vertices: vertices ?? [], edges: edges ?? [] })
    .layout("ForceDirected")
    .lazyRender()
    ;

}
function cell_25(graph, filteredCallsMap) {

graph
    .highlightVerticies(filteredCallsMap)
    .lazyRender()
;

}
function cell_26(phonesTimeLineData, display) {

const calls = Object.keys(phonesTimeLineData.events).map((key) => {
  const row = phonesTimeLineData.events[key];
  const caller = phonesTimeLineData.entities[row.entityIds[0]];
  return {
    id: key,
    caller_id: +row.entityIds[0],
    callee_id: +row.entityIds[1],
    caller_type: caller.type,
    start: new Date(row.time.start),
    end: new Date(row.time.end),
    duration: new Date(row.time.end) - new Date(row.time.start)
  };
});
display(calls);
const callRange = {
  start: new Date(Math.min(...calls.map(c => c.start))),
  end: new Date(Math.max(...calls.map(c => c.end)))
};
display(callRange);
return {calls,callRange};

}
async function cell_27(display) {

const { test } = await import("./lib.js").then((module) => {
  if (!("test" in module)) throw new SyntaxError(`export 'test' not found`);
  return module;
});

const xxx = test();
display(xxx);
return {test,xxx};

}
function cell_28(md) {

return (
md`---

## Timeline Helpers
`
)

}
function cell_29(md) {

return (
md`phoneIdToEntityDict`
)

}
function cell_30(phonesTimeLineData, display) {

const phoneIdToEntityDict = {};
for (const [id, entity] of Object.entries(phonesTimeLineData.entities)) {
  phoneIdToEntityDict[+id] = entity;
}
display(phoneIdToEntityDict);
return {phoneIdToEntityDict};

}
function cell_31(md) {

return (
md`phoneEntityTypeToTypeDict`
)

}
function cell_32(phonesTimeLineData, display) {

const phoneEntityTypeToTypeDict = {};
for (const [id, entity] of Object.entries(phonesTimeLineData.entityTypes)) {
  phoneEntityTypeToTypeDict[id] = entity;
}
display(phoneEntityTypeToTypeDict);
return {phoneEntityTypeToTypeDict};

}
function cell_33(md) {

return (
md`idToEntityLabelDict`
)

}
function cell_34(entityLabelToIdDict, display) {

const idToEntityLabelDict = {};
for (const [label, id] of Object.entries(entityLabelToIdDict)) {
  idToEntityLabelDict[+id] = label;
}
display(idToEntityLabelDict);
return {idToEntityLabelDict};

}
function cell_35(callRange, d3, margin, width) {

function getDate(date) {
  return new Date(date.toISOString().split('T')[0]);
}

const now = callRange.start;
const until = callRange.end;

const nowDate = new Date(callRange.start.getUTCFullYear(), 0, 1);
const untilDate = new Date(callRange.end.getUTCFullYear(), 11, 31);

const scaleX = d3.scaleUtc().domain([nowDate, untilDate]).range([margin.left, width - margin.right]);
return {getDate,now,until,nowDate,untilDate,scaleX};

}
function cell_36() {

const margin = ({ top: 80, right: 20, bottom: 20, left: 20 }); 
return {margin};

}
function cell_37(Timeline, timelineData, scaleX) {

const timeline = Timeline(timelineData, {
  from: scaleX.domain()[0],
  until: scaleX.domain()[1]
})
return {timeline};

}
function cell_38(d3, width, dodge) {

function Timeline(data, options) {
  const axis = {};
  const nodes = {};
  let _data = data;

  const { from, until, margin, height, onClickItem, onZoomEnd, zoomFilter } = {
    from: new Date().setFullYear(new Date().getFullYear() + 1),
    until: new Date().setFullYear(new Date().getFullYear() + 1),
    margin: { top: 80, right: 20, bottom: 20, left: 20 },
    height: 200,
    onClickItem: () => { },
    onZoomEnd: () => { },
    zoomFilter: () => { },
    ...options
  };

  const MS_PER_HOUR = 60 * 60 * 1000;
  const MS_PER_SECOND = 1000;
  const MS_PER_DAY = 24 * MS_PER_HOUR;
  const MS_PER_YEAR = 365.24 * MS_PER_DAY; // include leap year

  const parts = ["yearly", "daily", "weekly", "grid", "yearlyGrid"];

  let scaleX = d3
    .scaleUtc()
    .domain([from, until])
    .range([margin.left, width - margin.right]);

  const originalScaleX = scaleX.copy();

  const density = Math.abs(scaleX.invert(0) - scaleX.invert(1)) / MS_PER_HOUR; // in pixels per hour

  const zoomScaleExtent = [1, Math.round(MS_PER_YEAR * 10)];

  const findDensityConfig = (map, value) => {
    for (const [limit, config] of map) {
      if (value < limit) {
        return config;
      }
    }

    return [];
  };

  const ensureTimeFormat = (value = "") => {
    return typeof value !== "function" ? d3.utcFormat(value) : value;
  };

  axis["yearly"] = (parentNode, density) => {
    const densityMap = [
      [0.0005, [d3.utcHour, "%B %-d, %Y %H:%M"]],
      [0.05, [d3.utcDay, "%B %-d, %Y"]],
      [
        3,
        [
          d3.utcMonth,
          (d) => {
            const startOfTheYear =
              d.getUTCMonth() === 0 && d.getUTCDate() === 1;
            const format = startOfTheYear ? "%Y – %B" : "%B";

            return d3.utcFormat(format)(d);
          }
        ]
      ],
      [Infinity, [d3.utcYear, "%Y"]]
    ];

    let [interval, format] = findDensityConfig(densityMap, density);
    format = ensureTimeFormat(format);

    const el = parentNode
      .attr("transform", `translate(0,${margin.top - 48})`)
      .call(
        d3.axisTop(scaleX).ticks(interval).tickFormat(format).tickSizeOuter(0)
      );

    el.select(".domain").remove();

    el.selectAll("text")
      .attr("y", 0)
      .attr("x", 6)
      .style("text-anchor", "start");

    el.selectAll("line").attr("y1", -7).attr("y2", 6);
  };

  axis["daily"] = (parentNode, density) => {
    const densityMap = [
      [0.0005, [d3.utcMinute, "%M"]],
      [0.05, [d3.utcHour, "%H"]],
      [1, [d3.utcDay, "%-d"]],
      [3, [d3.utcDay, ""]],
      [8, [d3.utcMonth, "%B"]],
      [13, [d3.utcMonth, "%b"]],
      [22, [d3.utcMonth, (d) => d3.utcFormat("%B")(d).charAt(0)]],
      [33, [d3.utcMonth.every(3), "Q%q"]],
      [Infinity, [d3.utcMonth.every(3), ""]]
    ];

    let [interval, format] = findDensityConfig(densityMap, density);
    format = ensureTimeFormat(format);

    const el = parentNode
      .attr("transform", `translate(0,${margin.top - 28})`)
      .call(
        d3.axisTop(scaleX).ticks(interval).tickFormat(format).tickSizeOuter(0)
      );

    el.select(".domain").remove();

    el.selectAll("text")
      .attr("y", 0)
      .attr("x", 6)
      .style("text-anchor", "start");

    el.selectAll("line").attr("y1", -7).attr("y2", 0);
  };

  axis["weekly"] = (parentNode, density) => {
    const densityMap = [
      [10, [d3.timeMonday, (d) => +d3.utcFormat("%-W")(d) + 1]], // monday as first of week and zero based
      [33, [d3.timeMonday, ""]],
      [Infinity, [d3.timeMonday.every(4), ""]]
    ];

    let [interval, format] = findDensityConfig(densityMap, density);
    format = ensureTimeFormat(format);

    const el = parentNode
      .attr("transform", `translate(0,${margin.top - 8})`)
      .call(
        d3.axisTop(scaleX).ticks(interval).tickFormat(format).tickSizeOuter(0)
      );

    el.select(".domain").remove();
    el.selectAll("line").style(
      "visibility",
      density > densityMap[0][0] ? "visible" : "hidden"
    );

    el.selectAll("text")
      .attr("y", 0)
      .attr("x", 6)
      .style("text-anchor", "start");

    el.selectAll("line").attr("y1", -7).attr("y2", 0);
  };

  axis["grid"] = (parentNode, density) => {
    const densityMap = [
      [0.001, [d3.utcMinute]],
      [0.025, [d3.utcMinute.every(30)]],
      [0.05, [d3.utcHour]],
      [0.5, [d3.utcHour.every(6)]],
      [1, [d3.utcDay]],
      [8, [d3.timeMonday]],
      [22, [d3.utcMonth]],
      [Infinity, [d3.utcMonth.every(3)]]
    ];

    const [interval] = findDensityConfig(densityMap, density);

    const el = parentNode
      .attr("transform", `translate(0,${margin.top})`)
      .call(d3.axisTop(scaleX).ticks(interval).tickSizeOuter(0));

    el.select(".domain").remove();
    el.selectAll("text").remove();

    el.selectAll("line")
      .attr("stroke-width", 0.5)
      .attr("y1", 0)
      .attr("y2", height - margin.top - margin.bottom);
  };

  axis["yearlyGrid"] = (parentNode, density) => {
    const densityMap = [
      [3, [d3.utcMonth, "%B"]],
      [Infinity, [d3.utcYear, "%Y"]]
    ];

    let [interval, format] = findDensityConfig(densityMap, density);
    format = ensureTimeFormat(format);

    const el = parentNode
      .attr("transform", `translate(0,${margin.top})`)
      .call(
        d3.axisTop(scaleX).ticks(interval).tickFormat(format).tickSizeOuter(0)
      );

    el.select(".domain").remove();
    el.selectAll("text").remove();

    el.selectAll("line")
      .attr("y1", 0)
      .attr("y2", height - margin.top - margin.bottom);
  };

  const setup = () => {
    const svg = d3
      .create("svg")
      .attr("width", width)
      .attr("height", height)
      .attr("viewBox", [0, 0, width, height])
      .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

    const element = svg.node();

    const rootNode = svg.append("g").classed("timeline-axis", true);

    parts.forEach((part) => {
      nodes[part] = rootNode.append("g").classed(part, true);
    });

    const radius = 4;
    const padding = 1;

    const bind = (data) => {
      const I = d3.range(data.length);
      const X = data.map((d) => scaleX(d.day));
      const Y = dodge(X, radius * 2 + padding);
      const countExtent = d3.extent(data, (d) => d.count);
      const color = d3.scaleSequential(d3.interpolateBuPu).domain(countExtent);
      const items = svg
        .selectAll("circle")
        .data(data)
        .join(
          (enter) =>
            enter
              .append("circle")
              .on("click", onClickItem)
              // .style("stroke", "white")
              // .style("stroke-width", 1)
              .style("fill", (d) => color(d.count))
              .style("cursor", "pointer")
              .attr("r", 4)
              .attr("cx", (d, i) => X[i])
              .attr("cy", (d, i) => Y[i] + 120)
              .append("title")
              .text((d) => d.id),
          (update) =>
            update.style("fill", (d) => color(d.count)).attr("cx", (d, i) => X[i]).attr("cy", (d, i) => Y[i] + 130)
        );

      const density =
        Math.abs(scaleX.invert(0) - scaleX.invert(1)) / MS_PER_HOUR; // in pixels per hour

      parts.forEach((part) => {
        nodes[part].call(axis[part], density);
      });
      return items;
    };

    const getBounds = () => {
      return { start: scaleX.domain()[0], end: scaleX.domain()[1] };
    };

    const items = bind(data);

    const zoom = d3
      .zoom()
      .scaleExtent(zoomScaleExtent)
      .extent([
        [margin.left, 0],
        [width - margin.right, 0]
      ])
      .translateExtent([
        [margin.left, 0],
        [width - margin.right, 0]
      ])
      .on("zoom", ({ transform }) => {
        scaleX = transform.rescaleX(originalScaleX);
        bind(_data);
        element.value = {
          start: scaleX.domain()[0],
          end: scaleX.domain()[1]
        };
        element.dispatchEvent(new CustomEvent("input"));
      });
    svg.call(zoom);

    const update = (data) => {
      _data = data;
      bind(_data);
    };

    return {
      element,
      update,
      items,
      getBounds
    };
  };

  return setup();
}
return {Timeline};

}
function cell_39(d3) {

function dodge(X, radius) {
  const Y = new Float64Array(X.length);
  const radius2 = radius ** 2;
  const epsilon = 1e-3;
  let head = null,
    tail = null;

  // Returns true if circle ⟨x, y⟩ intersects with any circle in the queue.
  const intersects = (x, y) => {
    let a = head;
    while (a) {
      const ai = a.index;
      if (radius2 - epsilon > (X[ai] - x) ** 2 + (Y[ai] - y) ** 2) return true;
      a = a.next;
    }
    return false;
  };

  // Place each circle sequentially.
  for (const bi of d3.range(X.length).sort((i, j) => X[i] - X[j])) {
    while (head && X[head.index] < X[bi] - radius2) head = head.next; // Remove non-intersecting

    // Start by attempting to place at y = 0, check for intersections.
    Y[bi] = 0;
    if (intersects(X[bi], Y[bi])) {
      let a = head;
      Y[bi] = Infinity; // Start with a high Y value which will be minimized.

      do {
        const ai = a.index;
        const distX = X[ai] - X[bi];
        const distToEdge = Math.sqrt(radius2 - distX * distX);

        // Check above each circle
        let y1 = Y[ai] + distToEdge;
        if (Math.abs(y1) < Math.abs(Y[bi]) && !intersects(X[bi], y1))
          Y[bi] = y1;

        // Check below each circle
        let y2 = Y[ai] - distToEdge;
        if (Math.abs(y2) < Math.abs(Y[bi]) && !intersects(X[bi], y2))
          Y[bi] = y2;

        a = a.next;
      } while (a);
    }

    // Add b to the queue.
    const b = { index: bi, next: null };
    if (head === null) head = tail = b;
    else tail = tail.next = b;
  }

  return Y;
}
return {dodge};

}
function cell_40(Plot, d3) {

function beeswarm(
  data,
  { gap = 1, ticks = 50, dynamic = false, direction, ...options }
) {
  const dots = Plot.dot(data, options);
  const { render } = dots;

  dots.render = function () {
    const g = render.apply(this, arguments);
    const circles = d3.select(g).selectAll("circle");

    const nodes = [];
    const [cx, cy, x, y, forceX, forceY] =
      direction === "x"
        ? ["cx", "cy", "x", "y", d3.forceX, d3.forceY]
        : ["cy", "cx", "y", "x", d3.forceY, d3.forceX];
    for (const c of circles) {
      const node = {
        x: +c.getAttribute(cx),
        y: +c.getAttribute(cy),
        r: +c.getAttribute("r")
      };
      nodes.push(node);
    }
    const force = d3
      .forceSimulation(nodes)
      .force("x", forceX((d) => d[x]).strength(0.8))
      .force("y", forceY((d) => d[y]).strength(0.05))
      .force(
        "collide",
        d3
          .forceCollide()
          .radius((d) => d.r + gap)
          .iterations(3)
      )
      .tick(ticks)
      .stop();
    update();
    if (dynamic) force.on("tick", update).restart();
    return g;

    function update() {
      circles.attr(cx, (_, i) => nodes[i].x).attr(cy, (_, i) => nodes[i].y);
    }
  };

  return dots;
}
return {beeswarm};

}
function cell_41(filteredBinnedCalls, display) {

const timelineData = filteredBinnedCalls.map((x, i) => ({
  id: i,
  day: x.day,
  count: x.count
}))
display(timelineData);
return {timelineData};

}
function cell_42(html) {

return (
html`
<style type="text/css">
  .timeline-axis {
    --daily-gridline-color: rgb(194, 199, 200);
    --yearly-gridline-color: rgb(81, 93, 93);
    --yearly-tick-color: rgb(81, 93, 93);
    --yearly-label-color: rgb(60, 79, 81);
    --daily-tick-color: rgb(161, 173, 173);
    --daily-label-color: rgb(60, 79, 81);
    --weekly-tick-color: rgb(161, 173, 173);
    --weekly-label-color: rgb(60, 79, 81);
  }

  .timeline-axis line {
    shape-rendering: geometricPrecision;
    stroke-width: 0.5;
  }

  .timeline-axis .yearly line {
    stroke: var(--yearly-tick-color);
  }

  .timeline-axis .yearly text {
    color: var(--yearly-label-color);
  }

  .timeline-axis .daily line {
    stroke: var(--daily-tick-color);
  }

  .timeline-axis .daily text {
    color: var(--daily-label-color);
  }

  .timeline-axis .weekly line {
    stroke: var(--weekly-tick-color);
  }

  .timeline-axis .weekly text {
    color: var(--weekly-label-color);
  }

  .timeline-axis .grid line {
    stroke: var(--daily-gridline-color);
  }

  .timeline-axis .yearlyGrid line {
    stroke: var(--yearly-gridline-color);
  }
</style>
`
)

}
function cell_43(md) {

return (
md`---
`
)

}
function cell_44(md) {

return (
md`
### Data Loaders
`
)

}
function cell_45(md) {

return (
md`adjacencyList`
)

}
async function cell_46(FileAttachment, display) {

const adjacencyList = await FileAttachment("./data/adjacencyList.json").json().then(display);
return {adjacencyList};

}
function cell_47(md) {

return (
md`timeBarData`
)

}
async function cell_48(FileAttachment, display) {

const timeBarData = await FileAttachment("./data/timeBarData.json").json().then(display);
return {timeBarData};

}
function cell_49(md) {

return (
md`groupToChartIdsDict`
)

}
async function cell_50(FileAttachment, display) {

const groupToChartIdsDict = await FileAttachment("./data/groupToChartIdsDict.json").json().then(display);
return {groupToChartIdsDict};

}
function cell_51(md) {

return (
md`phonesChartData`
)

}
async function cell_52(FileAttachment, display) {

const phonesChartData = await FileAttachment("./data/phonesChartData.json").json().then(display);
return {phonesChartData};

}
function cell_53(md) {

return (
md`entityLabelToIdDict`
)

}
async function cell_54(FileAttachment, display) {

const entityLabelToIdDict = await FileAttachment("./data/entityLabelToIdDict.json").json().then(display);
return {entityLabelToIdDict};

}
function cell_55(md) {

return (
md`phonesTimeLineData`
)

}
async function cell_56(FileAttachment, display) {

const phonesTimeLineData = await FileAttachment("./data/phonesTimeLineData.json").json().then(display);
return {phonesTimeLineData};

}
const definitions = [
{
    "id": 1,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_1,
    "inputs": [
        "md",
        "filteredCalls"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 2,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_2,
    "inputs": [
        "display",
        "timeline"
    ],
    "outputs": [],
    "autodisplay": false
},
{
    "id": 3,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_3,
    "inputs": [
        "html",
        "width",
        "display"
    ],
    "outputs": [
        "GraphHtml",
        "placeholder",
        "graph"
    ],
    "autodisplay": false
},
{
    "id": 4,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_4,
    "inputs": [
        "d3"
    ],
    "outputs": [
        "binCalls"
    ],
    "autodisplay": false
},
{
    "id": 5,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_5,
    "inputs": [
        "d3"
    ],
    "outputs": [
        "binCallsByCluster"
    ],
    "autodisplay": false
},
{
    "id": 6,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_6,
    "inputs": [
        "binCalls",
        "calls"
    ],
    "outputs": [
        "binnedCalls"
    ],
    "autodisplay": false
},
{
    "id": 7,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_7,
    "inputs": [
        "binCalls",
        "filteredCalls"
    ],
    "outputs": [
        "filteredBinnedCalls"
    ],
    "autodisplay": false
},
{
    "id": 8,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_8,
    "inputs": [
        "binCallsByCluster",
        "calls",
        "filteredCalls"
    ],
    "outputs": [
        "binnedCallsByCluster",
        "filteredBinnedCallsByCluster"
    ],
    "autodisplay": false
},
{
    "id": 9,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_9,
    "inputs": [
        "Plot",
        "binnedCalls",
        "setStartEnd",
        "d3"
    ],
    "outputs": [],
    "autodisplay": true
},
{
    "id": 10,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_10,
    "inputs": [
        "Plot",
        "width",
        "filteredBinnedCallsByCluster",
        "phoneEntityTypeToTypeDict"
    ],
    "outputs": [],
    "autodisplay": true
},
{
    "id": 11,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_11,
    "inputs": [
        "Inputs",
        "filteredCalls",
        "backColor",
        "phoneIdToEntityDict",
        "formatDuration"
    ],
    "outputs": [],
    "autodisplay": true
},
{
    "id": 12,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_12,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 13,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_13,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 14,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_14,
    "inputs": [
        "Mutable",
        "calls",
        "start",
        "end"
    ],
    "outputs": [
        "filteredCallsMap",
        "filteredCalls"
    ],
    "autodisplay": false
},
{
    "id": 15,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_15,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 16,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_16,
    "inputs": [
        "display",
        "filteredCallsMap"
    ],
    "outputs": [],
    "autodisplay": false
},
{
    "id": 17,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_17,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 18,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_18,
    "inputs": [
        "display",
        "filteredCalls"
    ],
    "outputs": [],
    "autodisplay": false
},
{
    "id": 19,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_19,
    "inputs": [],
    "outputs": [
        "formatDuration"
    ],
    "autodisplay": false
},
{
    "id": 20,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_20,
    "inputs": [
        "d3",
        "htl",
        "phoneEntityTypeToTypeDict"
    ],
    "outputs": [
        "readableColor",
        "backColor"
    ],
    "autodisplay": false
},
{
    "id": 21,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_21,
    "inputs": [
        "Mutable"
    ],
    "outputs": [
        "start",
        "end",
        "setStartEnd"
    ],
    "autodisplay": false
},
{
    "id": 22,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_22,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 23,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_23,
    "inputs": [
        "Mutable",
        "adjacencyList",
        "phoneIdToEntityDict",
        "phoneEntityTypeToTypeDict"
    ],
    "outputs": [
        "idxMap",
        "edgeIdxMap",
        "vertices",
        "edges"
    ],
    "autodisplay": false
},
{
    "id": 24,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_24,
    "inputs": [
        "graph",
        "vertices",
        "edges"
    ],
    "outputs": [],
    "autodisplay": false
},
{
    "id": 25,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_25,
    "inputs": [
        "graph",
        "filteredCallsMap"
    ],
    "outputs": [],
    "autodisplay": false
},
{
    "id": 26,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_26,
    "inputs": [
        "phonesTimeLineData",
        "display"
    ],
    "outputs": [
        "calls",
        "callRange"
    ],
    "autodisplay": false
},
{
    "id": 27,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_27,
    "inputs": [
        "display"
    ],
    "outputs": [
        "test",
        "xxx"
    ],
    "autodisplay": false
},
{
    "id": 28,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_28,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 29,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_29,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 30,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_30,
    "inputs": [
        "phonesTimeLineData",
        "display"
    ],
    "outputs": [
        "phoneIdToEntityDict"
    ],
    "autodisplay": false
},
{
    "id": 31,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_31,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 32,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_32,
    "inputs": [
        "phonesTimeLineData",
        "display"
    ],
    "outputs": [
        "phoneEntityTypeToTypeDict"
    ],
    "autodisplay": false
},
{
    "id": 33,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_33,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 34,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_34,
    "inputs": [
        "entityLabelToIdDict",
        "display"
    ],
    "outputs": [
        "idToEntityLabelDict"
    ],
    "autodisplay": false
},
{
    "id": 35,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_35,
    "inputs": [
        "callRange",
        "d3",
        "margin",
        "width"
    ],
    "outputs": [
        "getDate",
        "now",
        "until",
        "nowDate",
        "untilDate",
        "scaleX"
    ],
    "autodisplay": false
},
{
    "id": 36,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_36,
    "inputs": [],
    "outputs": [
        "margin"
    ],
    "autodisplay": false
},
{
    "id": 37,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_37,
    "inputs": [
        "Timeline",
        "timelineData",
        "scaleX"
    ],
    "outputs": [
        "timeline"
    ],
    "autodisplay": false
},
{
    "id": 38,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_38,
    "inputs": [
        "d3",
        "width",
        "dodge"
    ],
    "outputs": [
        "Timeline"
    ],
    "autodisplay": false
},
{
    "id": 39,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_39,
    "inputs": [
        "d3"
    ],
    "outputs": [
        "dodge"
    ],
    "autodisplay": false
},
{
    "id": 40,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_40,
    "inputs": [
        "Plot",
        "d3"
    ],
    "outputs": [
        "beeswarm"
    ],
    "autodisplay": false
},
{
    "id": 41,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_41,
    "inputs": [
        "filteredBinnedCalls",
        "display"
    ],
    "outputs": [
        "timelineData"
    ],
    "autodisplay": false
},
{
    "id": 42,
    "mode": "html",
    "pinned": false,
    "hidden": false,
    "body": cell_42,
    "inputs": [
        "html"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 43,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_43,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 44,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_44,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 45,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_45,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 46,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_46,
    "inputs": [
        "FileAttachment",
        "display"
    ],
    "outputs": [
        "adjacencyList"
    ],
    "autodisplay": false
},
{
    "id": 47,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_47,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 48,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_48,
    "inputs": [
        "FileAttachment",
        "display"
    ],
    "outputs": [
        "timeBarData"
    ],
    "autodisplay": false
},
{
    "id": 49,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_49,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 50,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_50,
    "inputs": [
        "FileAttachment",
        "display"
    ],
    "outputs": [
        "groupToChartIdsDict"
    ],
    "autodisplay": false
},
{
    "id": 51,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_51,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 52,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_52,
    "inputs": [
        "FileAttachment",
        "display"
    ],
    "outputs": [
        "phonesChartData"
    ],
    "autodisplay": false
},
{
    "id": 53,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_53,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 54,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_54,
    "inputs": [
        "FileAttachment",
        "display"
    ],
    "outputs": [
        "entityLabelToIdDict"
    ],
    "autodisplay": false
},
{
    "id": 55,
    "mode": "md",
    "pinned": false,
    "hidden": false,
    "body": cell_55,
    "inputs": [
        "md"
    ],
    "outputs": [],
    "autodisplay": true,
    "autoview": false
},
{
    "id": 56,
    "mode": "js",
    "pinned": false,
    "hidden": false,
    "body": cell_56,
    "inputs": [
        "FileAttachment",
        "display"
    ],
    "outputs": [
        "phonesTimeLineData"
    ],
    "autodisplay": false
}
];
export default definitions;
